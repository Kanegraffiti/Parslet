# Parslet Project Report

## Problem Definition
Edge and low-cost devices often need to run automated workflows without reliable connectivity or abundant power. Existing workflow frameworks depend heavily on cloud resources. Parslet addresses this by providing a lightweight, offline-first engine for Python tasks.

## Constraints
* **Power**: Many target platforms run on battery or solar with limited capacity. Parslet offers a battery-saver mode that reduces concurrency.
* **Compute & Memory**: Devices like single board computers have few CPU cores and modest RAM. The scheduler adapts worker count based on available resources.
* **Connectivity**: Workflows must continue when completely offline. Parslet avoids network dependencies and supports checkpointing to resume after outages.

## Design Alternatives and Decisions
Early prototypes experimented with using heavier frameworks such as Dask and Parsl directly. These systems provide rich features but drag in many dependencies and presume constant network access. Ultimately we opted for a small custom DAG runner that only requires the `networkx` graph library. Optional adapters are included so existing Dask or Parsl workflows can be converted rather than re-written.

## Tools Used
* **Python 3.11+** for all core code.
* **networkx** for graph management.
* **psutil** to read memory and battery metrics.
* **pydot** and Graphviz (optional) to export DAG diagrams.
* **Rich** for colourful CLI output.

## Performance Benchmarks
The `DAGRunner` tracks execution times for each task. Below is a sample table generated by running `examples/hello.py` on a 2-core VM:

```
Task ID                 Status   Time(s)
add_08238910            SUCCESS  0.5020
add_98364266            SUCCESS  0.5030
square_dd1225c2         SUCCESS  0.5007
square_f8a9c459         SUCCESS  0.5005
sum_results_99bd7600    SUCCESS  0.5009
```

Even on a modest device the entire workflow completed in roughly half a second per task with minimal memory usage.

### Raspberry Pi Benchmarks
Running the same `hello.py` workflow on a Raspberry Pi 4 (4Â GB model) completes in about **2.1&nbsp;seconds** total with a peak memory usage around **15&nbsp;MB**. The table below was produced using `psutil` to measure the process after execution:

```
Metric        Value
------------  -----
Runtime(s)    2.1
Peak RAM(MB)  15
```

The console output captured directly on the device is available as `docs/assets/hello_output.svg`.
## Usage Guidance
Example workflows can be executed with:

```
python run_all_examples.py
```

Each workflow prints its results along with benchmark statistics. If optional libraries such as `matplotlib` are missing, the script skips those examples and continues.
